/*
 * generated by Xtext 2.26.0
 */
package org.xtext.example.mydsl.generator

import componentbasedsystem.repository.AtomicComponent
import componentbasedsystem.repository.Interface
import componentbasedsystem.repository.Parameter
import componentbasedsystem.repository.Repository
import componentbasedsystem.repository.Signature
import componentbasedsystem.repository.types.SimpleType
import componentbasedsystem.repository.types.Type
import componentbasedsystem.repository.types.Void
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class CBSToJavaGenerator extends AbstractGenerator {
	
	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
	
		/*
		 * TODO list:
		 * - add name to repository
		 * - separate code of generators
		 */
		 
		 var repositories = resource.allContents.toIterable.filter(Repository);
		 var repositoryCounter = 1;
		 
   		 for(repository: repositories) {
   		 	var String repositoryName;
   		 	
   		 	if(repositories.size <= 1){
   		 		repositoryName = "repository";
   		 	} else {
   		 		repositoryName = "repository" + repositoryCounter;
   		 		repositoryCounter++;
   		 	}
   		 	
   		 	fsa.generateFile(repositoryName + "/Helper.java", repository.compile)
   		 	
   		 	for(i: repository.interfaces) {
       		 fsa.generateFile(repositoryName + "/I" + i.name + ".java", i.compile)
   		 	}
   		 	
   		 	for(atomicComponent: repository.components){
   		 		fsa.generateFile(repositoryName + "/" + atomicComponent.name + "/" + atomicComponent.name + "Impl.java", atomicComponent.compile)
   		 	}
   		 }
	}
	
	def compile(Repository repository)'''
		package repository;
		     
		public class Helper {
			public static void assertNotNull(Object interface){
				assert interface != null;
			}
		}
		'''
	
	def compile(Interface i)'''
		package repository;
		
		public interface I«i.name» {
			«FOR signature: i.signatures»
				«signature.compile»
			«ENDFOR»
		}'''
			
	def compile(AtomicComponent atomicComponent) '''
		package repository.«atomicComponent.name»;
		
		«FOR requiredInterface: atomicComponent.requires»
			import repository.I«requiredInterface.name»;
		«ENDFOR»
		import repository.Helper;
		
		public class «atomicComponent.name»Impl «FOR providedInterface: atomicComponent.provides BEFORE 'implements ' SEPARATOR ','»I«providedInterface.name»«ENDFOR» {
			«FOR requiredInterface: atomicComponent.requires»
			I«requiredInterface.name» i«requiredInterface.name»;
			«ENDFOR»
			
			«FOR requiredInterface: atomicComponent.requires»
			public void setI«requiredInterface.name»(I«requiredInterface.name» i«requiredInterface.name»){
				Helper.assertNotNull(this.i«requiredInterface.name»);
				this.i«requiredInterface.name» = i«requiredInterface.name»;
			}
			«ENDFOR»
			
			«FOR providedInterface: atomicComponent.provides»«FOR method: providedInterface.signatures»
			//Implementing «method.name» from interface I«providedInterface.name»
			@Override
			public «method.returnType.compile» «method.name»(«FOR parameter: method.parameters SEPARATOR ', '»«parameter.compile»«ENDFOR»){
				«FOR requiredInterface: atomicComponent.requires»
				Helper.assertNotNull(this.i«requiredInterface.name»);
				«ENDFOR»
				// TODO: insert code here
			}
			
			«ENDFOR»«ENDFOR»
		}
	'''
	
	def compile(Signature signature)'''
	    public «signature.returnType.name» «signature.name»(«FOR parameter: signature.parameters SEPARATOR ', '»«parameter.compile»«ENDFOR»);
	  	'''
  
    def compile(Parameter parameter)
    	'''«parameter.type.compile» «parameter.name»'''

	def compile(Type type)
		'''«IF type instanceof Void»void«ELSEIF type instanceof SimpleType»«type.type.getName().toLowerCase()»«ELSE»notSupportedType«ENDIF»'''
}